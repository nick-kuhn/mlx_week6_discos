TOPIC: reinforcement_learning
TITLE: The fundamental problem with training language models
CONTENT: We want to get a model that's good, but ideally we would like to get 20 million samples of supervised fine-tuning data. 50 million, 100 million units, must have a lot of data so that we do retraining there. We cannot do that, so we come up with all sorts of tricks to approximate it or to allow the model to do it by itself and find some proxies, some approximators where we can kind of do what that massive supervised fine-tuning would have done. This is the big problem we're trying to solve - we don't have enough high-quality training data, so we need to find ways to make the model learn from limited examples or learn to evaluate itself.

TOPIC: reinforcement_learning
TITLE: The basics of reinforcement learning for AI systems
CONTENT: There is a field of study called reinforcement learning, which comes from computer science back from the 1950s, and the main idea is that if I'm an environmental actor, we can have an agent here. The agent produces actions, the actions produce a new state or environment, and maybe it would produce some reward occasionally, ideally always, but we don't always get reward for your efforts at every single moment, so you kind of have to be long thinking. So we call them sparse rewards, and those can be fed back into the agent, and the agent can learn from this reward and state, and then it can give you another action. The dream is that if you do this loop enough, the computer will learn what to do just from trial and error.

TOPIC: machine_learning
TITLE: Why reinforcement learning might lead to AGI breakthrough
CONTENT: If you do this loop enough, hopefully the dream is that we're gonna get AGI. So we're just letting the computer learn from rewards and we learn what to do. And we already know this works with our friend AlphaGo, like AlphaGo Zero, these sort of systems, and now we can achieve superhuman performance, which really means that they start from nothing and they do better than humans. So maybe if we can crack this with language models, we're gonna get an LLM that somehow will be better than the original data anyway. We'll kind of learn to be smarter, if we just sort of give it an environment and then we'll learn to think, and we'll do better than the humans can do. This is like a bit of a dream, but there's some evidence it might work.

TOPIC: ai_research
TITLE: Recent breakthrough in reasoning efficiency with RL models
CONTENT: There was this paper coming out at the end of May that showed that so far, reinforcement learning has not been something that can give superhuman performance, but it can extract the knowledge from LLMs much faster. So if you have a base model, you have to give it a few shots and learn from a few examples, and then ask it to answer your question. Or you might even ask the base model many, many times the same question, and you kind of open the temperature, and you always want to get the right answer. What they noticed is that if you try to sample one time from a reinforcement learning model, a reasoning model, versus just a base model, the reinforcement learning model is way more efficient at giving you the correct answer. This suggests that RL training teaches models to reason more effectively in a single pass.

TOPIC: ai_research
TITLE: The efficiency advantage of trained reasoning models over base models
CONTENT: If you ask a base model one time, only 20% of the time will it give you something useful. So you have to sample five times to get your answer. While the reinforcement learning model, going through reasoning steps, 40% of the time immediately gives you the right result. So you get double the efficiency. You don't have to ask it many times to get the answer. They took this a step further and noticed that maybe what reinforcement learning is doing with reasoning is just increasing some coefficient. Basically all we have to say is that we're not giving up on the base model - we hope it works, but if you come with a reinforcement learning model, I can take the base model and do better than you by asking it more times.

TOPIC: machine_learning
TITLE: The challenge with base models versus trained models in practice
CONTENT: All we have to say is that if you take a base model and I take a reinforcement learning model that you trained, I can beat you. No matter how much reinforcement learning you're doing, I will beat you if I ask the base model 128 times the same question and I wait through all those answers. I will do much better than you just asking your reinforcement learning model once, because you went through some training that may have caused catastrophic forgetting. You're kind of trading off the reinforcement learning model because you're trying to give it what you want, but that actually hurts its performance. So it seems like we can learn better than the base model, but there's a big trade-off here. This is the best shot that we have at getting a better model.

TOPIC: ai_training
TITLE: The three-model architecture for RLHF training
CONTENT: What do we do? We take our supervised fine-tuning model, we start from here and we call it a policy. That's the first step, super easy. Then we have three models that are all the same model in one way or another, because they do different tasks. The first one is our SFT model that we call policy. We take our SFT model and we do some training so that the SFT model now is called the reward model. The only thing it's good at is given two answers, telling which one is better, given a question and two candidate answers. The way we achieve this reward model training is by using pairwise comparison structure where we present pairs of answers and ask which is better.

TOPIC: ai_training
TITLE: How reward models work in practice and implementation
CONTENT: The way we achieve this reward model training is by using pairwise comparison. We take our SFT model and we pass to it two answers. The reward model, what is it? It's the SFT model, but the only thing that we change is that in the last layer, we go to a regression task. So we don't predict the next token, but we just take the hidden state and project it to a number. Because clearly, our SFT model is a language model that predicts the next token, but the reward model doesn't predict the next token - it predicts a number. How do we do it? We change the last layer to take the hidden state and project it to a scalar value. So we take the prompt, which is the question, then we put the answer, both of them together, and then we change the reward model head to output a single number.

TOPIC: ai_training
TITLE: Training reward models with preference pairs and loss functions
CONTENT: We don't know what those numbers are, so we can't look at them and say four is good enough or 2.5 is too low. We use a pairwise loss function where we just want the difference between them to be high. We don't care about the absolute number at this stage, because we don't know it anyway. We put the same question and then the winning answer and the losing answer, and we hope that the difference in scores is bigger. We maximize the log of the sigmoid of the difference, instead of just the absolute difference. The reasoning is that we want the probabilities to go from zero to one, and the log sigmoid naturally handles this transformation. This is a common choice in preference learning where we're comparing pairs rather than learning absolute values.

TOPIC: ai_training
TITLE: The value model in reinforcement learning systems
CONTENT: We have a value model. What is a value model? This is a bit weird - you probably haven't seen a value model before in language model training. Most of the time, the value model is the policy model itself, with the only caveat that we add another head on top of it that predicts a scalar. The value model is basically the policy model but with another head on top of it. We're going to talk about the value and the advantage, which is this nice generalized advantage estimation. The value model tries to predict how good a particular state is, independent of the action taken. This is a concept borrowed from traditional reinforcement learning where we need to estimate the expected future rewards from any given state.

TOPIC: ai_training
TITLE: The core problem of reward shaping in language models
CONTENT: We use the reward model to give us a score for the generated text. Now we have to do something called reward shaping, where that score is for all the text. But we don't want that - remember we need a loss for each token. How do I backpropagate? The reward model gives me a score of five for the whole answer. How do I spread this five somehow across each token? This is called reward shaping, which is a massive research area. There's a problem though - how do we take this single score and distribute it across all the tokens in the sequence? This is not trivial because different tokens contribute differently to the overall quality of the answer.

TOPIC: ai_training
TITLE: The KL divergence regularization trick and reference models
CONTENT: We calculate the reward as the difference between the policy probability and the reference model probability. The reference model is the initial SFT that we have at the beginning of training, and that stays frozen forever. Every time the policy produces output, we send each token to the reference model and ask what it thinks. If the reference model assigns very low probability because now the policy has a different probability, we want to take that into account. We want to take the fact that we're moving away from the SFT model, from the reference model. This is something that we want - we do want to move away from the reference model, but we don't want to move too much. So we're going to constantly calculate the KL divergence between the policy and reference model.

TOPIC: ai_training
TITLE: Why we need the reference model constraint to prevent collapse
CONTENT: We kind of want to move away from the reference model - we do want that - but we don't want to move too much. We're going to constantly calculate the KL divergence between the policy and reference model. If you just train the model on "my name is Bob" and you backpropagate three times, the model will forget everything. Because you're just moving in that direction. So when you ask what is a car, it's just going to say "my name is Bob." We don't want that. Can you imagine how easy it would be for the model to completely go crazy? So KL divergence regularization is something that is used everywhere to prevent this kind of catastrophic forgetting and mode collapse.

TOPIC: ai_training
TITLE: The token-level reward calculation process in detail
CONTENT: For each token, we calculate a reward. The first part is the difference between the policy likelihood and the reference likelihood for that token. This is just regularization - we're not really learning anything besides staying close to the reference model. But then we do something: we give the last token an extra reward score that came from the reward model. We have a problem now - we have different types of rewards for different tokens. As I said, the first part is just how much we deviate from the reference, compared to the policy. This is just regularization. We're not really learning anything besides staying close to the SFT model. But we did something now - we gave the last token the complete reward from the reward model.

TOPIC: ai_training
TITLE: Why only the last token gets the reward signal in RLHF
CONTENT: Why do you only get a reward for the last token? Because that's how we decided to do this. There's a design choice - if you have other approaches, you can decide to split the reward differently. The decision is to give the reward at the end. The reward is for the whole answer, not for individual tokens. We use a Kronecker delta function - it's zero for all tokens except the last one, which gets the full reward from the reward model. This makes sense because we're evaluating the complete response, not individual words. Some researchers have experimented with giving rewards to individual tokens, but that requires a different kind of reward model that can evaluate partial sequences, which is much more complex to train and less reliable.